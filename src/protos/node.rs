// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `node.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct P2PRequest {
    // message fields
    pub requestType: P2PREQTYPE,
    pub all: bool,
    pub verbose: bool,
    pub protocolName: ::std::string::String,
    pub listenAddress: ::std::string::String,
    pub targetAddress: ::std::string::String,
    pub remoteAddress: ::std::string::String,
    pub allowCustomProtocols: bool,
    pub reportPeerID: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P2PRequest {
    fn default() -> &'a P2PRequest {
        <P2PRequest as ::protobuf::Message>::default_instance()
    }
}

impl P2PRequest {
    pub fn new() -> P2PRequest {
        ::std::default::Default::default()
    }

    // .pb.P2PREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> P2PREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: P2PREQTYPE) {
        self.requestType = v;
    }

    // bool all = 2;


    pub fn get_all(&self) -> bool {
        self.all
    }
    pub fn clear_all(&mut self) {
        self.all = false;
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.all = v;
    }

    // bool verbose = 3;


    pub fn get_verbose(&self) -> bool {
        self.verbose
    }
    pub fn clear_verbose(&mut self) {
        self.verbose = false;
    }

    // Param is passed by value, moved
    pub fn set_verbose(&mut self, v: bool) {
        self.verbose = v;
    }

    // string protocolName = 4;


    pub fn get_protocolName(&self) -> &str {
        &self.protocolName
    }
    pub fn clear_protocolName(&mut self) {
        self.protocolName.clear();
    }

    // Param is passed by value, moved
    pub fn set_protocolName(&mut self, v: ::std::string::String) {
        self.protocolName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocolName(&mut self) -> &mut ::std::string::String {
        &mut self.protocolName
    }

    // Take field
    pub fn take_protocolName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.protocolName, ::std::string::String::new())
    }

    // string listenAddress = 5;


    pub fn get_listenAddress(&self) -> &str {
        &self.listenAddress
    }
    pub fn clear_listenAddress(&mut self) {
        self.listenAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_listenAddress(&mut self, v: ::std::string::String) {
        self.listenAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listenAddress(&mut self) -> &mut ::std::string::String {
        &mut self.listenAddress
    }

    // Take field
    pub fn take_listenAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.listenAddress, ::std::string::String::new())
    }

    // string targetAddress = 6;


    pub fn get_targetAddress(&self) -> &str {
        &self.targetAddress
    }
    pub fn clear_targetAddress(&mut self) {
        self.targetAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetAddress(&mut self, v: ::std::string::String) {
        self.targetAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAddress(&mut self) -> &mut ::std::string::String {
        &mut self.targetAddress
    }

    // Take field
    pub fn take_targetAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.targetAddress, ::std::string::String::new())
    }

    // string remoteAddress = 7;


    pub fn get_remoteAddress(&self) -> &str {
        &self.remoteAddress
    }
    pub fn clear_remoteAddress(&mut self) {
        self.remoteAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_remoteAddress(&mut self, v: ::std::string::String) {
        self.remoteAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remoteAddress(&mut self) -> &mut ::std::string::String {
        &mut self.remoteAddress
    }

    // Take field
    pub fn take_remoteAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remoteAddress, ::std::string::String::new())
    }

    // bool allowCustomProtocols = 8;


    pub fn get_allowCustomProtocols(&self) -> bool {
        self.allowCustomProtocols
    }
    pub fn clear_allowCustomProtocols(&mut self) {
        self.allowCustomProtocols = false;
    }

    // Param is passed by value, moved
    pub fn set_allowCustomProtocols(&mut self, v: bool) {
        self.allowCustomProtocols = v;
    }

    // bool reportPeerID = 9;


    pub fn get_reportPeerID(&self) -> bool {
        self.reportPeerID
    }
    pub fn clear_reportPeerID(&mut self) {
        self.reportPeerID = false;
    }

    // Param is passed by value, moved
    pub fn set_reportPeerID(&mut self, v: bool) {
        self.reportPeerID = v;
    }
}

impl ::protobuf::Message for P2PRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.verbose = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocolName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.listenAddress)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.targetAddress)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remoteAddress)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowCustomProtocols = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reportPeerID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != P2PREQTYPE::CLOSE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if self.all != false {
            my_size += 2;
        }
        if self.verbose != false {
            my_size += 2;
        }
        if !self.protocolName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.protocolName);
        }
        if !self.listenAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.listenAddress);
        }
        if !self.targetAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.targetAddress);
        }
        if !self.remoteAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.remoteAddress);
        }
        if self.allowCustomProtocols != false {
            my_size += 2;
        }
        if self.reportPeerID != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != P2PREQTYPE::CLOSE {
            os.write_enum(1, self.requestType.value())?;
        }
        if self.all != false {
            os.write_bool(2, self.all)?;
        }
        if self.verbose != false {
            os.write_bool(3, self.verbose)?;
        }
        if !self.protocolName.is_empty() {
            os.write_string(4, &self.protocolName)?;
        }
        if !self.listenAddress.is_empty() {
            os.write_string(5, &self.listenAddress)?;
        }
        if !self.targetAddress.is_empty() {
            os.write_string(6, &self.targetAddress)?;
        }
        if !self.remoteAddress.is_empty() {
            os.write_string(7, &self.remoteAddress)?;
        }
        if self.allowCustomProtocols != false {
            os.write_bool(8, self.allowCustomProtocols)?;
        }
        if self.reportPeerID != false {
            os.write_bool(9, self.reportPeerID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P2PRequest {
        P2PRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<P2PREQTYPE>>(
                    "requestType",
                    |m: &P2PRequest| { &m.requestType },
                    |m: &mut P2PRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "all",
                    |m: &P2PRequest| { &m.all },
                    |m: &mut P2PRequest| { &mut m.all },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "verbose",
                    |m: &P2PRequest| { &m.verbose },
                    |m: &mut P2PRequest| { &mut m.verbose },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protocolName",
                    |m: &P2PRequest| { &m.protocolName },
                    |m: &mut P2PRequest| { &mut m.protocolName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "listenAddress",
                    |m: &P2PRequest| { &m.listenAddress },
                    |m: &mut P2PRequest| { &mut m.listenAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "targetAddress",
                    |m: &P2PRequest| { &m.targetAddress },
                    |m: &mut P2PRequest| { &mut m.targetAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remoteAddress",
                    |m: &P2PRequest| { &m.remoteAddress },
                    |m: &mut P2PRequest| { &mut m.remoteAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allowCustomProtocols",
                    |m: &P2PRequest| { &m.allowCustomProtocols },
                    |m: &mut P2PRequest| { &mut m.allowCustomProtocols },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reportPeerID",
                    |m: &P2PRequest| { &m.reportPeerID },
                    |m: &mut P2PRequest| { &mut m.reportPeerID },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<P2PRequest>(
                    "P2PRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static P2PRequest {
        static mut instance: ::protobuf::lazy::Lazy<P2PRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(P2PRequest::new)
        }
    }
}

impl ::protobuf::Clear for P2PRequest {
    fn clear(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
        self.all = false;
        self.verbose = false;
        self.protocolName.clear();
        self.listenAddress.clear();
        self.targetAddress.clear();
        self.remoteAddress.clear();
        self.allowCustomProtocols = false;
        self.reportPeerID = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P2PRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P2PResponse {
    // message fields
    pub requestType: P2PREQTYPE,
    pub names: ::protobuf::RepeatedField<::std::string::String>,
    pub connsClosed: i32,
    pub streamInfos: ::protobuf::RepeatedField<P2PLsInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P2PResponse {
    fn default() -> &'a P2PResponse {
        <P2PResponse as ::protobuf::Message>::default_instance()
    }
}

impl P2PResponse {
    pub fn new() -> P2PResponse {
        ::std::default::Default::default()
    }

    // .pb.P2PREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> P2PREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: P2PREQTYPE) {
        self.requestType = v;
    }

    // repeated string names = 2;


    pub fn get_names(&self) -> &[::std::string::String] {
        &self.names
    }
    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }

    // int32 connsClosed = 3;


    pub fn get_connsClosed(&self) -> i32 {
        self.connsClosed
    }
    pub fn clear_connsClosed(&mut self) {
        self.connsClosed = 0;
    }

    // Param is passed by value, moved
    pub fn set_connsClosed(&mut self, v: i32) {
        self.connsClosed = v;
    }

    // repeated .pb.P2PLsInfo streamInfos = 4;


    pub fn get_streamInfos(&self) -> &[P2PLsInfo] {
        &self.streamInfos
    }
    pub fn clear_streamInfos(&mut self) {
        self.streamInfos.clear();
    }

    // Param is passed by value, moved
    pub fn set_streamInfos(&mut self, v: ::protobuf::RepeatedField<P2PLsInfo>) {
        self.streamInfos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_streamInfos(&mut self) -> &mut ::protobuf::RepeatedField<P2PLsInfo> {
        &mut self.streamInfos
    }

    // Take field
    pub fn take_streamInfos(&mut self) -> ::protobuf::RepeatedField<P2PLsInfo> {
        ::std::mem::replace(&mut self.streamInfos, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P2PResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.streamInfos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.connsClosed = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.streamInfos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != P2PREQTYPE::CLOSE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.connsClosed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.connsClosed, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.streamInfos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != P2PREQTYPE::CLOSE {
            os.write_enum(1, self.requestType.value())?;
        }
        for v in &self.names {
            os.write_string(2, &v)?;
        };
        if self.connsClosed != 0 {
            os.write_int32(3, self.connsClosed)?;
        }
        for v in &self.streamInfos {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P2PResponse {
        P2PResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<P2PREQTYPE>>(
                    "requestType",
                    |m: &P2PResponse| { &m.requestType },
                    |m: &mut P2PResponse| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "names",
                    |m: &P2PResponse| { &m.names },
                    |m: &mut P2PResponse| { &mut m.names },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "connsClosed",
                    |m: &P2PResponse| { &m.connsClosed },
                    |m: &mut P2PResponse| { &mut m.connsClosed },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P2PLsInfo>>(
                    "streamInfos",
                    |m: &P2PResponse| { &m.streamInfos },
                    |m: &mut P2PResponse| { &mut m.streamInfos },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<P2PResponse>(
                    "P2PResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static P2PResponse {
        static mut instance: ::protobuf::lazy::Lazy<P2PResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(P2PResponse::new)
        }
    }
}

impl ::protobuf::Clear for P2PResponse {
    fn clear(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
        self.names.clear();
        self.connsClosed = 0;
        self.streamInfos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P2PResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P2PLsInfo {
    // message fields
    pub protocolName: ::std::string::String,
    pub listenAddress: ::std::string::String,
    pub targetAddress: ::std::string::String,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P2PLsInfo {
    fn default() -> &'a P2PLsInfo {
        <P2PLsInfo as ::protobuf::Message>::default_instance()
    }
}

impl P2PLsInfo {
    pub fn new() -> P2PLsInfo {
        ::std::default::Default::default()
    }

    // string protocolName = 1;


    pub fn get_protocolName(&self) -> &str {
        &self.protocolName
    }
    pub fn clear_protocolName(&mut self) {
        self.protocolName.clear();
    }

    // Param is passed by value, moved
    pub fn set_protocolName(&mut self, v: ::std::string::String) {
        self.protocolName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocolName(&mut self) -> &mut ::std::string::String {
        &mut self.protocolName
    }

    // Take field
    pub fn take_protocolName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.protocolName, ::std::string::String::new())
    }

    // string listenAddress = 2;


    pub fn get_listenAddress(&self) -> &str {
        &self.listenAddress
    }
    pub fn clear_listenAddress(&mut self) {
        self.listenAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_listenAddress(&mut self, v: ::std::string::String) {
        self.listenAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listenAddress(&mut self) -> &mut ::std::string::String {
        &mut self.listenAddress
    }

    // Take field
    pub fn take_listenAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.listenAddress, ::std::string::String::new())
    }

    // string targetAddress = 3;


    pub fn get_targetAddress(&self) -> &str {
        &self.targetAddress
    }
    pub fn clear_targetAddress(&mut self) {
        self.targetAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetAddress(&mut self, v: ::std::string::String) {
        self.targetAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAddress(&mut self) -> &mut ::std::string::String {
        &mut self.targetAddress
    }

    // Take field
    pub fn take_targetAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.targetAddress, ::std::string::String::new())
    }

    // bool local = 4;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for P2PLsInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocolName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.listenAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.targetAddress)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.protocolName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.protocolName);
        }
        if !self.listenAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.listenAddress);
        }
        if !self.targetAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.targetAddress);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.protocolName.is_empty() {
            os.write_string(1, &self.protocolName)?;
        }
        if !self.listenAddress.is_empty() {
            os.write_string(2, &self.listenAddress)?;
        }
        if !self.targetAddress.is_empty() {
            os.write_string(3, &self.targetAddress)?;
        }
        if self.local != false {
            os.write_bool(4, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P2PLsInfo {
        P2PLsInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protocolName",
                    |m: &P2PLsInfo| { &m.protocolName },
                    |m: &mut P2PLsInfo| { &mut m.protocolName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "listenAddress",
                    |m: &P2PLsInfo| { &m.listenAddress },
                    |m: &mut P2PLsInfo| { &mut m.listenAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "targetAddress",
                    |m: &P2PLsInfo| { &m.targetAddress },
                    |m: &mut P2PLsInfo| { &mut m.targetAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "local",
                    |m: &P2PLsInfo| { &m.local },
                    |m: &mut P2PLsInfo| { &mut m.local },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<P2PLsInfo>(
                    "P2PLsInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static P2PLsInfo {
        static mut instance: ::protobuf::lazy::Lazy<P2PLsInfo> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(P2PLsInfo::new)
        }
    }
}

impl ::protobuf::Clear for P2PLsInfo {
    fn clear(&mut self) {
        self.protocolName.clear();
        self.listenAddress.clear();
        self.targetAddress.clear();
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P2PLsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PLsInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeersResponse {
    // message fields
    pub peerIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeersResponse {
    fn default() -> &'a GetPeersResponse {
        <GetPeersResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPeersResponse {
    pub fn new() -> GetPeersResponse {
        ::std::default::Default::default()
    }

    // repeated string peerIDs = 1;


    pub fn get_peerIDs(&self) -> &[::std::string::String] {
        &self.peerIDs
    }
    pub fn clear_peerIDs(&mut self) {
        self.peerIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerIDs
    }

    // Take field
    pub fn take_peerIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetPeersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peerIDs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peerIDs {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeersResponse {
        GetPeersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peerIDs",
                    |m: &GetPeersResponse| { &m.peerIDs },
                    |m: &mut GetPeersResponse| { &mut m.peerIDs },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPeersResponse>(
                    "GetPeersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeersResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetPeersResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetPeersResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetPeersResponse {
    fn clear(&mut self) {
        self.peerIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnMgmtRequest {
    // message fields
    pub requestType: CONNMGMTREQTYPE,
    pub multiAddrs: ::protobuf::RepeatedField<::std::string::String>,
    pub peerIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnMgmtRequest {
    fn default() -> &'a ConnMgmtRequest {
        <ConnMgmtRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnMgmtRequest {
    pub fn new() -> ConnMgmtRequest {
        ::std::default::Default::default()
    }

    // .pb.CONNMGMTREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> CONNMGMTREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: CONNMGMTREQTYPE) {
        self.requestType = v;
    }

    // repeated string multiAddrs = 2;


    pub fn get_multiAddrs(&self) -> &[::std::string::String] {
        &self.multiAddrs
    }
    pub fn clear_multiAddrs(&mut self) {
        self.multiAddrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_multiAddrs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.multiAddrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_multiAddrs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.multiAddrs
    }

    // Take field
    pub fn take_multiAddrs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.multiAddrs, ::protobuf::RepeatedField::new())
    }

    // repeated string peerIDs = 3;


    pub fn get_peerIDs(&self) -> &[::std::string::String] {
        &self.peerIDs
    }
    pub fn clear_peerIDs(&mut self) {
        self.peerIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerIDs
    }

    // Take field
    pub fn take_peerIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConnMgmtRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.multiAddrs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.multiAddrs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.peerIDs {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            os.write_enum(1, self.requestType.value())?;
        }
        for v in &self.multiAddrs {
            os.write_string(2, &v)?;
        };
        for v in &self.peerIDs {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnMgmtRequest {
        ConnMgmtRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CONNMGMTREQTYPE>>(
                    "requestType",
                    |m: &ConnMgmtRequest| { &m.requestType },
                    |m: &mut ConnMgmtRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "multiAddrs",
                    |m: &ConnMgmtRequest| { &m.multiAddrs },
                    |m: &mut ConnMgmtRequest| { &mut m.multiAddrs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peerIDs",
                    |m: &ConnMgmtRequest| { &m.peerIDs },
                    |m: &mut ConnMgmtRequest| { &mut m.peerIDs },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnMgmtRequest>(
                    "ConnMgmtRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnMgmtRequest {
        static mut instance: ::protobuf::lazy::Lazy<ConnMgmtRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ConnMgmtRequest::new)
        }
    }
}

impl ::protobuf::Clear for ConnMgmtRequest {
    fn clear(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
        self.multiAddrs.clear();
        self.peerIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnMgmtRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnMgmtRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnMgmtResponse {
    // message fields
    pub requestType: CONNMGMTREQTYPE,
    pub connected: ::std::collections::HashMap<::std::string::String, bool>,
    pub status: ::std::collections::HashMap<::std::string::String, ConnMgmtStatus>,
    pub peerIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnMgmtResponse {
    fn default() -> &'a ConnMgmtResponse {
        <ConnMgmtResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConnMgmtResponse {
    pub fn new() -> ConnMgmtResponse {
        ::std::default::Default::default()
    }

    // .pb.CONNMGMTREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> CONNMGMTREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: CONNMGMTREQTYPE) {
        self.requestType = v;
    }

    // repeated .pb.ConnMgmtResponse.ConnectedEntry connected = 2;


    pub fn get_connected(&self) -> &::std::collections::HashMap<::std::string::String, bool> {
        &self.connected
    }
    pub fn clear_connected(&mut self) {
        self.connected.clear();
    }

    // Param is passed by value, moved
    pub fn set_connected(&mut self, v: ::std::collections::HashMap<::std::string::String, bool>) {
        self.connected = v;
    }

    // Mutable pointer to the field.
    pub fn mut_connected(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, bool> {
        &mut self.connected
    }

    // Take field
    pub fn take_connected(&mut self) -> ::std::collections::HashMap<::std::string::String, bool> {
        ::std::mem::replace(&mut self.connected, ::std::collections::HashMap::new())
    }

    // repeated .pb.ConnMgmtResponse.StatusEntry status = 3;


    pub fn get_status(&self) -> &::std::collections::HashMap<::std::string::String, ConnMgmtStatus> {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::collections::HashMap<::std::string::String, ConnMgmtStatus>) {
        self.status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ConnMgmtStatus> {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::collections::HashMap<::std::string::String, ConnMgmtStatus> {
        ::std::mem::replace(&mut self.status, ::std::collections::HashMap::new())
    }

    // repeated string peerIDs = 4;


    pub fn get_peerIDs(&self) -> &[::std::string::String] {
        &self.peerIDs
    }
    pub fn clear_peerIDs(&mut self) {
        self.peerIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerIDs
    }

    // Take field
    pub fn take_peerIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConnMgmtResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(wire_type, is, &mut self.connected)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(wire_type, is, &mut self.status)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(2, &self.connected);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(3, &self.status);
        for value in &self.peerIDs {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            os.write_enum(1, self.requestType.value())?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(2, &self.connected, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(3, &self.status, os)?;
        for v in &self.peerIDs {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnMgmtResponse {
        ConnMgmtResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CONNMGMTREQTYPE>>(
                    "requestType",
                    |m: &ConnMgmtResponse| { &m.requestType },
                    |m: &mut ConnMgmtResponse| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(
                    "connected",
                    |m: &ConnMgmtResponse| { &m.connected },
                    |m: &mut ConnMgmtResponse| { &mut m.connected },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(
                    "status",
                    |m: &ConnMgmtResponse| { &m.status },
                    |m: &mut ConnMgmtResponse| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peerIDs",
                    |m: &ConnMgmtResponse| { &m.peerIDs },
                    |m: &mut ConnMgmtResponse| { &mut m.peerIDs },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnMgmtResponse>(
                    "ConnMgmtResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnMgmtResponse {
        static mut instance: ::protobuf::lazy::Lazy<ConnMgmtResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ConnMgmtResponse::new)
        }
    }
}

impl ::protobuf::Clear for ConnMgmtResponse {
    fn clear(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
        self.connected.clear();
        self.status.clear();
        self.peerIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnMgmtResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnMgmtResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnMgmtStatus {
    // message fields
    pub disconnected: bool,
    pub reason: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnMgmtStatus {
    fn default() -> &'a ConnMgmtStatus {
        <ConnMgmtStatus as ::protobuf::Message>::default_instance()
    }
}

impl ConnMgmtStatus {
    pub fn new() -> ConnMgmtStatus {
        ::std::default::Default::default()
    }

    // bool disconnected = 1;


    pub fn get_disconnected(&self) -> bool {
        self.disconnected
    }
    pub fn clear_disconnected(&mut self) {
        self.disconnected = false;
    }

    // Param is passed by value, moved
    pub fn set_disconnected(&mut self, v: bool) {
        self.disconnected = v;
    }

    // string reason = 2;


    pub fn get_reason(&self) -> &str {
        &self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        &mut self.reason
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reason, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConnMgmtStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disconnected = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.disconnected != false {
            my_size += 2;
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.reason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.disconnected != false {
            os.write_bool(1, self.disconnected)?;
        }
        if !self.reason.is_empty() {
            os.write_string(2, &self.reason)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnMgmtStatus {
        ConnMgmtStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "disconnected",
                    |m: &ConnMgmtStatus| { &m.disconnected },
                    |m: &mut ConnMgmtStatus| { &mut m.disconnected },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    |m: &ConnMgmtStatus| { &m.reason },
                    |m: &mut ConnMgmtStatus| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnMgmtStatus>(
                    "ConnMgmtStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnMgmtStatus {
        static mut instance: ::protobuf::lazy::Lazy<ConnMgmtStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ConnMgmtStatus::new)
        }
    }
}

impl ::protobuf::Clear for ConnMgmtStatus {
    fn clear(&mut self) {
        self.disconnected = false;
        self.reason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnMgmtStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnMgmtStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtrasRequest {
    // message fields
    pub requestType: EXTRASREQTYPE,
    pub extrasFeature: EXTRASTYPE,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtrasRequest {
    fn default() -> &'a ExtrasRequest {
        <ExtrasRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExtrasRequest {
    pub fn new() -> ExtrasRequest {
        ::std::default::Default::default()
    }

    // .pb.EXTRASREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> EXTRASREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = EXTRASREQTYPE::EX_ENABLE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: EXTRASREQTYPE) {
        self.requestType = v;
    }

    // .pb.EXTRASTYPE extrasFeature = 2;


    pub fn get_extrasFeature(&self) -> EXTRASTYPE {
        self.extrasFeature
    }
    pub fn clear_extrasFeature(&mut self) {
        self.extrasFeature = EXTRASTYPE::IDENTIFY;
    }

    // Param is passed by value, moved
    pub fn set_extrasFeature(&mut self, v: EXTRASTYPE) {
        self.extrasFeature = v;
    }
}

impl ::protobuf::Message for ExtrasRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.extrasFeature, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != EXTRASREQTYPE::EX_ENABLE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if self.extrasFeature != EXTRASTYPE::IDENTIFY {
            my_size += ::protobuf::rt::enum_size(2, self.extrasFeature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != EXTRASREQTYPE::EX_ENABLE {
            os.write_enum(1, self.requestType.value())?;
        }
        if self.extrasFeature != EXTRASTYPE::IDENTIFY {
            os.write_enum(2, self.extrasFeature.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtrasRequest {
        ExtrasRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EXTRASREQTYPE>>(
                    "requestType",
                    |m: &ExtrasRequest| { &m.requestType },
                    |m: &mut ExtrasRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EXTRASTYPE>>(
                    "extrasFeature",
                    |m: &ExtrasRequest| { &m.extrasFeature },
                    |m: &mut ExtrasRequest| { &mut m.extrasFeature },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExtrasRequest>(
                    "ExtrasRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExtrasRequest {
        static mut instance: ::protobuf::lazy::Lazy<ExtrasRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExtrasRequest::new)
        }
    }
}

impl ::protobuf::Clear for ExtrasRequest {
    fn clear(&mut self) {
        self.requestType = EXTRASREQTYPE::EX_ENABLE;
        self.extrasFeature = EXTRASTYPE::IDENTIFY;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtrasRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtrasRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockstoreRequest {
    // message fields
    pub requestType: BSREQTYPE,
    pub reqOpts: ::std::vec::Vec<BSREQOPTS>,
    pub cids: ::protobuf::RepeatedField<::std::string::String>,
    pub data: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub cidVersion: ::std::string::String,
    pub hashFunc: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockstoreRequest {
    fn default() -> &'a BlockstoreRequest {
        <BlockstoreRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlockstoreRequest {
    pub fn new() -> BlockstoreRequest {
        ::std::default::Default::default()
    }

    // .pb.BSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> BSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: BSREQTYPE) {
        self.requestType = v;
    }

    // repeated .pb.BSREQOPTS reqOpts = 2;


    pub fn get_reqOpts(&self) -> &[BSREQOPTS] {
        &self.reqOpts
    }
    pub fn clear_reqOpts(&mut self) {
        self.reqOpts.clear();
    }

    // Param is passed by value, moved
    pub fn set_reqOpts(&mut self, v: ::std::vec::Vec<BSREQOPTS>) {
        self.reqOpts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reqOpts(&mut self) -> &mut ::std::vec::Vec<BSREQOPTS> {
        &mut self.reqOpts
    }

    // Take field
    pub fn take_reqOpts(&mut self) -> ::std::vec::Vec<BSREQOPTS> {
        ::std::mem::replace(&mut self.reqOpts, ::std::vec::Vec::new())
    }

    // repeated string cids = 3;


    pub fn get_cids(&self) -> &[::std::string::String] {
        &self.cids
    }
    pub fn clear_cids(&mut self) {
        self.cids.clear();
    }

    // Param is passed by value, moved
    pub fn set_cids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cids
    }

    // Take field
    pub fn take_cids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cids, ::protobuf::RepeatedField::new())
    }

    // repeated bytes data = 4;


    pub fn get_data(&self) -> &[::std::vec::Vec<u8>] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    // string cidVersion = 5;


    pub fn get_cidVersion(&self) -> &str {
        &self.cidVersion
    }
    pub fn clear_cidVersion(&mut self) {
        self.cidVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_cidVersion(&mut self, v: ::std::string::String) {
        self.cidVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cidVersion(&mut self) -> &mut ::std::string::String {
        &mut self.cidVersion
    }

    // Take field
    pub fn take_cidVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cidVersion, ::std::string::String::new())
    }

    // string hashFunc = 7;


    pub fn get_hashFunc(&self) -> &str {
        &self.hashFunc
    }
    pub fn clear_hashFunc(&mut self) {
        self.hashFunc.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashFunc(&mut self, v: ::std::string::String) {
        self.hashFunc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hashFunc(&mut self) -> &mut ::std::string::String {
        &mut self.hashFunc
    }

    // Take field
    pub fn take_hashFunc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hashFunc, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BlockstoreRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.reqOpts, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cidVersion)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hashFunc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != BSREQTYPE::BS_DELETE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.reqOpts {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in &self.cids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.data {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if !self.cidVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.cidVersion);
        }
        if !self.hashFunc.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.hashFunc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != BSREQTYPE::BS_DELETE {
            os.write_enum(1, self.requestType.value())?;
        }
        for v in &self.reqOpts {
            os.write_enum(2, v.value())?;
        };
        for v in &self.cids {
            os.write_string(3, &v)?;
        };
        for v in &self.data {
            os.write_bytes(4, &v)?;
        };
        if !self.cidVersion.is_empty() {
            os.write_string(5, &self.cidVersion)?;
        }
        if !self.hashFunc.is_empty() {
            os.write_string(7, &self.hashFunc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockstoreRequest {
        BlockstoreRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BSREQTYPE>>(
                    "requestType",
                    |m: &BlockstoreRequest| { &m.requestType },
                    |m: &mut BlockstoreRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BSREQOPTS>>(
                    "reqOpts",
                    |m: &BlockstoreRequest| { &m.reqOpts },
                    |m: &mut BlockstoreRequest| { &mut m.reqOpts },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cids",
                    |m: &BlockstoreRequest| { &m.cids },
                    |m: &mut BlockstoreRequest| { &mut m.cids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &BlockstoreRequest| { &m.data },
                    |m: &mut BlockstoreRequest| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cidVersion",
                    |m: &BlockstoreRequest| { &m.cidVersion },
                    |m: &mut BlockstoreRequest| { &mut m.cidVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hashFunc",
                    |m: &BlockstoreRequest| { &m.hashFunc },
                    |m: &mut BlockstoreRequest| { &mut m.hashFunc },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockstoreRequest>(
                    "BlockstoreRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockstoreRequest {
        static mut instance: ::protobuf::lazy::Lazy<BlockstoreRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BlockstoreRequest::new)
        }
    }
}

impl ::protobuf::Clear for BlockstoreRequest {
    fn clear(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
        self.reqOpts.clear();
        self.cids.clear();
        self.data.clear();
        self.cidVersion.clear();
        self.hashFunc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockstoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockstoreRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockstoreResponse {
    // message fields
    pub requestType: BSREQTYPE,
    pub blocks: ::protobuf::RepeatedField<Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockstoreResponse {
    fn default() -> &'a BlockstoreResponse {
        <BlockstoreResponse as ::protobuf::Message>::default_instance()
    }
}

impl BlockstoreResponse {
    pub fn new() -> BlockstoreResponse {
        ::std::default::Default::default()
    }

    // .pb.BSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> BSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: BSREQTYPE) {
        self.requestType = v;
    }

    // repeated .pb.Block blocks = 2;


    pub fn get_blocks(&self) -> &[Block] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockstoreResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != BSREQTYPE::BS_DELETE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != BSREQTYPE::BS_DELETE {
            os.write_enum(1, self.requestType.value())?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockstoreResponse {
        BlockstoreResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BSREQTYPE>>(
                    "requestType",
                    |m: &BlockstoreResponse| { &m.requestType },
                    |m: &mut BlockstoreResponse| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "blocks",
                    |m: &BlockstoreResponse| { &m.blocks },
                    |m: &mut BlockstoreResponse| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockstoreResponse>(
                    "BlockstoreResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockstoreResponse {
        static mut instance: ::protobuf::lazy::Lazy<BlockstoreResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BlockstoreResponse::new)
        }
    }
}

impl ::protobuf::Clear for BlockstoreResponse {
    fn clear(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockstoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockstoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message fields
    pub cid: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    pub size: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // string cid = 1;


    pub fn get_cid(&self) -> &str {
        &self.cid
    }
    pub fn clear_cid(&mut self) {
        self.cid.clear();
    }

    // Param is passed by value, moved
    pub fn set_cid(&mut self, v: ::std::string::String) {
        self.cid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cid(&mut self) -> &mut ::std::string::String {
        &mut self.cid
    }

    // Take field
    pub fn take_cid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cid, ::std::string::String::new())
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // int64 size = 3;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cid);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cid.is_empty() {
            os.write_string(1, &self.cid)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if self.size != 0 {
            os.write_int64(3, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cid",
                    |m: &Block| { &m.cid },
                    |m: &mut Block| { &mut m.cid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Block| { &m.data },
                    |m: &mut Block| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "size",
                    |m: &Block| { &m.size },
                    |m: &mut Block| { &mut m.size },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Block::new)
        }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.cid.clear();
        self.data.clear();
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DagRequest {
    // message fields
    pub requestType: DAGREQTYPE,
    pub data: ::std::vec::Vec<u8>,
    pub objectEncoding: ::std::string::String,
    pub serializationFormat: ::std::string::String,
    pub hashFunc: ::std::string::String,
    pub cidVersion: i64,
    pub hash: ::std::string::String,
    pub links: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DagRequest {
    fn default() -> &'a DagRequest {
        <DagRequest as ::protobuf::Message>::default_instance()
    }
}

impl DagRequest {
    pub fn new() -> DagRequest {
        ::std::default::Default::default()
    }

    // .pb.DAGREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> DAGREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: DAGREQTYPE) {
        self.requestType = v;
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string objectEncoding = 3;


    pub fn get_objectEncoding(&self) -> &str {
        &self.objectEncoding
    }
    pub fn clear_objectEncoding(&mut self) {
        self.objectEncoding.clear();
    }

    // Param is passed by value, moved
    pub fn set_objectEncoding(&mut self, v: ::std::string::String) {
        self.objectEncoding = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectEncoding(&mut self) -> &mut ::std::string::String {
        &mut self.objectEncoding
    }

    // Take field
    pub fn take_objectEncoding(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.objectEncoding, ::std::string::String::new())
    }

    // string serializationFormat = 4;


    pub fn get_serializationFormat(&self) -> &str {
        &self.serializationFormat
    }
    pub fn clear_serializationFormat(&mut self) {
        self.serializationFormat.clear();
    }

    // Param is passed by value, moved
    pub fn set_serializationFormat(&mut self, v: ::std::string::String) {
        self.serializationFormat = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serializationFormat(&mut self) -> &mut ::std::string::String {
        &mut self.serializationFormat
    }

    // Take field
    pub fn take_serializationFormat(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serializationFormat, ::std::string::String::new())
    }

    // string hashFunc = 5;


    pub fn get_hashFunc(&self) -> &str {
        &self.hashFunc
    }
    pub fn clear_hashFunc(&mut self) {
        self.hashFunc.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashFunc(&mut self, v: ::std::string::String) {
        self.hashFunc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hashFunc(&mut self) -> &mut ::std::string::String {
        &mut self.hashFunc
    }

    // Take field
    pub fn take_hashFunc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hashFunc, ::std::string::String::new())
    }

    // int64 cidVersion = 6;


    pub fn get_cidVersion(&self) -> i64 {
        self.cidVersion
    }
    pub fn clear_cidVersion(&mut self) {
        self.cidVersion = 0;
    }

    // Param is passed by value, moved
    pub fn set_cidVersion(&mut self, v: i64) {
        self.cidVersion = v;
    }

    // string hash = 7;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    // repeated .pb.DagRequest.LinksEntry links = 8;


    pub fn get_links(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.links, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for DagRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.objectEncoding)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serializationFormat)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hashFunc)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cidVersion = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.links)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != DAGREQTYPE::DAG_PUT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if !self.objectEncoding.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.objectEncoding);
        }
        if !self.serializationFormat.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.serializationFormat);
        }
        if !self.hashFunc.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.hashFunc);
        }
        if self.cidVersion != 0 {
            my_size += ::protobuf::rt::value_size(6, self.cidVersion, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.hash);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.links);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != DAGREQTYPE::DAG_PUT {
            os.write_enum(1, self.requestType.value())?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if !self.objectEncoding.is_empty() {
            os.write_string(3, &self.objectEncoding)?;
        }
        if !self.serializationFormat.is_empty() {
            os.write_string(4, &self.serializationFormat)?;
        }
        if !self.hashFunc.is_empty() {
            os.write_string(5, &self.hashFunc)?;
        }
        if self.cidVersion != 0 {
            os.write_int64(6, self.cidVersion)?;
        }
        if !self.hash.is_empty() {
            os.write_string(7, &self.hash)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.links, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DagRequest {
        DagRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DAGREQTYPE>>(
                    "requestType",
                    |m: &DagRequest| { &m.requestType },
                    |m: &mut DagRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &DagRequest| { &m.data },
                    |m: &mut DagRequest| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "objectEncoding",
                    |m: &DagRequest| { &m.objectEncoding },
                    |m: &mut DagRequest| { &mut m.objectEncoding },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serializationFormat",
                    |m: &DagRequest| { &m.serializationFormat },
                    |m: &mut DagRequest| { &mut m.serializationFormat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hashFunc",
                    |m: &DagRequest| { &m.hashFunc },
                    |m: &mut DagRequest| { &mut m.hashFunc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cidVersion",
                    |m: &DagRequest| { &m.cidVersion },
                    |m: &mut DagRequest| { &mut m.cidVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hash",
                    |m: &DagRequest| { &m.hash },
                    |m: &mut DagRequest| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "links",
                    |m: &DagRequest| { &m.links },
                    |m: &mut DagRequest| { &mut m.links },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DagRequest>(
                    "DagRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DagRequest {
        static mut instance: ::protobuf::lazy::Lazy<DagRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DagRequest::new)
        }
    }
}

impl ::protobuf::Clear for DagRequest {
    fn clear(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
        self.data.clear();
        self.objectEncoding.clear();
        self.serializationFormat.clear();
        self.hashFunc.clear();
        self.cidVersion = 0;
        self.hash.clear();
        self.links.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DagRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DagRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DagResponse {
    // message fields
    pub requestType: DAGREQTYPE,
    pub hashes: ::protobuf::RepeatedField<::std::string::String>,
    pub rawData: ::std::vec::Vec<u8>,
    pub links: ::protobuf::RepeatedField<IPLDLink>,
    pub nodeStats: ::std::collections::HashMap<::std::string::String, IPLDStat>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DagResponse {
    fn default() -> &'a DagResponse {
        <DagResponse as ::protobuf::Message>::default_instance()
    }
}

impl DagResponse {
    pub fn new() -> DagResponse {
        ::std::default::Default::default()
    }

    // .pb.DAGREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> DAGREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: DAGREQTYPE) {
        self.requestType = v;
    }

    // repeated string hashes = 2;


    pub fn get_hashes(&self) -> &[::std::string::String] {
        &self.hashes
    }
    pub fn clear_hashes(&mut self) {
        self.hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.hashes
    }

    // Take field
    pub fn take_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.hashes, ::protobuf::RepeatedField::new())
    }

    // bytes rawData = 3;


    pub fn get_rawData(&self) -> &[u8] {
        &self.rawData
    }
    pub fn clear_rawData(&mut self) {
        self.rawData.clear();
    }

    // Param is passed by value, moved
    pub fn set_rawData(&mut self, v: ::std::vec::Vec<u8>) {
        self.rawData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rawData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.rawData
    }

    // Take field
    pub fn take_rawData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.rawData, ::std::vec::Vec::new())
    }

    // repeated .pb.IPLDLink links = 4;


    pub fn get_links(&self) -> &[IPLDLink] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::protobuf::RepeatedField<IPLDLink>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::protobuf::RepeatedField<IPLDLink> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::protobuf::RepeatedField<IPLDLink> {
        ::std::mem::replace(&mut self.links, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.DagResponse.NodeStatsEntry nodeStats = 5;


    pub fn get_nodeStats(&self) -> &::std::collections::HashMap<::std::string::String, IPLDStat> {
        &self.nodeStats
    }
    pub fn clear_nodeStats(&mut self) {
        self.nodeStats.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeStats(&mut self, v: ::std::collections::HashMap<::std::string::String, IPLDStat>) {
        self.nodeStats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodeStats(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, IPLDStat> {
        &mut self.nodeStats
    }

    // Take field
    pub fn take_nodeStats(&mut self) -> ::std::collections::HashMap<::std::string::String, IPLDStat> {
        ::std::mem::replace(&mut self.nodeStats, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for DagResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.hashes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.rawData)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.links)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(wire_type, is, &mut self.nodeStats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != DAGREQTYPE::DAG_PUT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.hashes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.rawData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.rawData);
        }
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(5, &self.nodeStats);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != DAGREQTYPE::DAG_PUT {
            os.write_enum(1, self.requestType.value())?;
        }
        for v in &self.hashes {
            os.write_string(2, &v)?;
        };
        if !self.rawData.is_empty() {
            os.write_bytes(3, &self.rawData)?;
        }
        for v in &self.links {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(5, &self.nodeStats, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DagResponse {
        DagResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DAGREQTYPE>>(
                    "requestType",
                    |m: &DagResponse| { &m.requestType },
                    |m: &mut DagResponse| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hashes",
                    |m: &DagResponse| { &m.hashes },
                    |m: &mut DagResponse| { &mut m.hashes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "rawData",
                    |m: &DagResponse| { &m.rawData },
                    |m: &mut DagResponse| { &mut m.rawData },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IPLDLink>>(
                    "links",
                    |m: &DagResponse| { &m.links },
                    |m: &mut DagResponse| { &mut m.links },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(
                    "nodeStats",
                    |m: &DagResponse| { &m.nodeStats },
                    |m: &mut DagResponse| { &mut m.nodeStats },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DagResponse>(
                    "DagResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DagResponse {
        static mut instance: ::protobuf::lazy::Lazy<DagResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DagResponse::new)
        }
    }
}

impl ::protobuf::Clear for DagResponse {
    fn clear(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
        self.hashes.clear();
        self.rawData.clear();
        self.links.clear();
        self.nodeStats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DagResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DagResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPLDStat {
    // message fields
    pub numLinks: i64,
    pub blockSize: i64,
    pub linkSize: i64,
    pub cumulativeSize: i64,
    pub dataSize: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLDStat {
    fn default() -> &'a IPLDStat {
        <IPLDStat as ::protobuf::Message>::default_instance()
    }
}

impl IPLDStat {
    pub fn new() -> IPLDStat {
        ::std::default::Default::default()
    }

    // int64 numLinks = 1;


    pub fn get_numLinks(&self) -> i64 {
        self.numLinks
    }
    pub fn clear_numLinks(&mut self) {
        self.numLinks = 0;
    }

    // Param is passed by value, moved
    pub fn set_numLinks(&mut self, v: i64) {
        self.numLinks = v;
    }

    // int64 blockSize = 2;


    pub fn get_blockSize(&self) -> i64 {
        self.blockSize
    }
    pub fn clear_blockSize(&mut self) {
        self.blockSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockSize(&mut self, v: i64) {
        self.blockSize = v;
    }

    // int64 linkSize = 3;


    pub fn get_linkSize(&self) -> i64 {
        self.linkSize
    }
    pub fn clear_linkSize(&mut self) {
        self.linkSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_linkSize(&mut self, v: i64) {
        self.linkSize = v;
    }

    // int64 cumulativeSize = 4;


    pub fn get_cumulativeSize(&self) -> i64 {
        self.cumulativeSize
    }
    pub fn clear_cumulativeSize(&mut self) {
        self.cumulativeSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_cumulativeSize(&mut self, v: i64) {
        self.cumulativeSize = v;
    }

    // int64 dataSize = 5;


    pub fn get_dataSize(&self) -> i64 {
        self.dataSize
    }
    pub fn clear_dataSize(&mut self) {
        self.dataSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_dataSize(&mut self, v: i64) {
        self.dataSize = v;
    }
}

impl ::protobuf::Message for IPLDStat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numLinks = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockSize = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.linkSize = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cumulativeSize = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dataSize = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.numLinks != 0 {
            my_size += ::protobuf::rt::value_size(1, self.numLinks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockSize != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blockSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.linkSize != 0 {
            my_size += ::protobuf::rt::value_size(3, self.linkSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cumulativeSize != 0 {
            my_size += ::protobuf::rt::value_size(4, self.cumulativeSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dataSize != 0 {
            my_size += ::protobuf::rt::value_size(5, self.dataSize, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.numLinks != 0 {
            os.write_int64(1, self.numLinks)?;
        }
        if self.blockSize != 0 {
            os.write_int64(2, self.blockSize)?;
        }
        if self.linkSize != 0 {
            os.write_int64(3, self.linkSize)?;
        }
        if self.cumulativeSize != 0 {
            os.write_int64(4, self.cumulativeSize)?;
        }
        if self.dataSize != 0 {
            os.write_int64(5, self.dataSize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLDStat {
        IPLDStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "numLinks",
                    |m: &IPLDStat| { &m.numLinks },
                    |m: &mut IPLDStat| { &mut m.numLinks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "blockSize",
                    |m: &IPLDStat| { &m.blockSize },
                    |m: &mut IPLDStat| { &mut m.blockSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "linkSize",
                    |m: &IPLDStat| { &m.linkSize },
                    |m: &mut IPLDStat| { &mut m.linkSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cumulativeSize",
                    |m: &IPLDStat| { &m.cumulativeSize },
                    |m: &mut IPLDStat| { &mut m.cumulativeSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "dataSize",
                    |m: &IPLDStat| { &m.dataSize },
                    |m: &mut IPLDStat| { &mut m.dataSize },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPLDStat>(
                    "IPLDStat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IPLDStat {
        static mut instance: ::protobuf::lazy::Lazy<IPLDStat> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IPLDStat::new)
        }
    }
}

impl ::protobuf::Clear for IPLDStat {
    fn clear(&mut self) {
        self.numLinks = 0;
        self.blockSize = 0;
        self.linkSize = 0;
        self.cumulativeSize = 0;
        self.dataSize = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLDStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLDStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPLDLink {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub name: ::std::string::String,
    pub size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLDLink {
    fn default() -> &'a IPLDLink {
        <IPLDLink as ::protobuf::Message>::default_instance()
    }
}

impl IPLDLink {
    pub fn new() -> IPLDLink {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 size = 3;


    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }
}

impl ::protobuf::Message for IPLDLink {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.size != 0 {
            os.write_uint64(3, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLDLink {
        IPLDLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &IPLDLink| { &m.hash },
                    |m: &mut IPLDLink| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &IPLDLink| { &m.name },
                    |m: &mut IPLDLink| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "size",
                    |m: &IPLDLink| { &m.size },
                    |m: &mut IPLDLink| { &mut m.size },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPLDLink>(
                    "IPLDLink",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IPLDLink {
        static mut instance: ::protobuf::lazy::Lazy<IPLDLink> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IPLDLink::new)
        }
    }
}

impl ::protobuf::Clear for IPLDLink {
    fn clear(&mut self) {
        self.hash.clear();
        self.name.clear();
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLDLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLDLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPLDNode {
    // message fields
    pub links: ::protobuf::RepeatedField<IPLDLink>,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLDNode {
    fn default() -> &'a IPLDNode {
        <IPLDNode as ::protobuf::Message>::default_instance()
    }
}

impl IPLDNode {
    pub fn new() -> IPLDNode {
        ::std::default::Default::default()
    }

    // repeated .pb.IPLDLink links = 2;


    pub fn get_links(&self) -> &[IPLDLink] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::protobuf::RepeatedField<IPLDLink>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::protobuf::RepeatedField<IPLDLink> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::protobuf::RepeatedField<IPLDLink> {
        ::std::mem::replace(&mut self.links, ::protobuf::RepeatedField::new())
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IPLDNode {
    fn is_initialized(&self) -> bool {
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.links)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.links {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLDNode {
        IPLDNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IPLDLink>>(
                    "links",
                    |m: &IPLDNode| { &m.links },
                    |m: &mut IPLDNode| { &mut m.links },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &IPLDNode| { &m.data },
                    |m: &mut IPLDNode| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPLDNode>(
                    "IPLDNode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IPLDNode {
        static mut instance: ::protobuf::lazy::Lazy<IPLDNode> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IPLDNode::new)
        }
    }
}

impl ::protobuf::Clear for IPLDNode {
    fn clear(&mut self) {
        self.links.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLDNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLDNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeystoreRequest {
    // message fields
    pub requestType: KSREQTYPE,
    pub name: ::std::string::String,
    pub privateKey: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeystoreRequest {
    fn default() -> &'a KeystoreRequest {
        <KeystoreRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeystoreRequest {
    pub fn new() -> KeystoreRequest {
        ::std::default::Default::default()
    }

    // .pb.KSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> KSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: KSREQTYPE) {
        self.requestType = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bytes privateKey = 3;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for KeystoreRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != KSREQTYPE::KS_HAS {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.privateKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != KSREQTYPE::KS_HAS {
            os.write_enum(1, self.requestType.value())?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.privateKey.is_empty() {
            os.write_bytes(3, &self.privateKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeystoreRequest {
        KeystoreRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KSREQTYPE>>(
                    "requestType",
                    |m: &KeystoreRequest| { &m.requestType },
                    |m: &mut KeystoreRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &KeystoreRequest| { &m.name },
                    |m: &mut KeystoreRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "privateKey",
                    |m: &KeystoreRequest| { &m.privateKey },
                    |m: &mut KeystoreRequest| { &mut m.privateKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeystoreRequest>(
                    "KeystoreRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeystoreRequest {
        static mut instance: ::protobuf::lazy::Lazy<KeystoreRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeystoreRequest::new)
        }
    }
}

impl ::protobuf::Clear for KeystoreRequest {
    fn clear(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
        self.name.clear();
        self.privateKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeystoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeystoreRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeystoreResponse {
    // message fields
    pub requestType: KSREQTYPE,
    pub privateKey: ::std::vec::Vec<u8>,
    pub keyNames: ::protobuf::RepeatedField<::std::string::String>,
    pub has: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeystoreResponse {
    fn default() -> &'a KeystoreResponse {
        <KeystoreResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeystoreResponse {
    pub fn new() -> KeystoreResponse {
        ::std::default::Default::default()
    }

    // .pb.KSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> KSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: KSREQTYPE) {
        self.requestType = v;
    }

    // bytes privateKey = 2;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }

    // repeated string keyNames = 3;


    pub fn get_keyNames(&self) -> &[::std::string::String] {
        &self.keyNames
    }
    pub fn clear_keyNames(&mut self) {
        self.keyNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyNames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.keyNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keyNames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.keyNames
    }

    // Take field
    pub fn take_keyNames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.keyNames, ::protobuf::RepeatedField::new())
    }

    // bool has = 4;


    pub fn get_has(&self) -> bool {
        self.has
    }
    pub fn clear_has(&mut self) {
        self.has = false;
    }

    // Param is passed by value, moved
    pub fn set_has(&mut self, v: bool) {
        self.has = v;
    }
}

impl ::protobuf::Message for KeystoreResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.keyNames)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != KSREQTYPE::KS_HAS {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.privateKey);
        }
        for value in &self.keyNames {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.has != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != KSREQTYPE::KS_HAS {
            os.write_enum(1, self.requestType.value())?;
        }
        if !self.privateKey.is_empty() {
            os.write_bytes(2, &self.privateKey)?;
        }
        for v in &self.keyNames {
            os.write_string(3, &v)?;
        };
        if self.has != false {
            os.write_bool(4, self.has)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeystoreResponse {
        KeystoreResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KSREQTYPE>>(
                    "requestType",
                    |m: &KeystoreResponse| { &m.requestType },
                    |m: &mut KeystoreResponse| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "privateKey",
                    |m: &KeystoreResponse| { &m.privateKey },
                    |m: &mut KeystoreResponse| { &mut m.privateKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "keyNames",
                    |m: &KeystoreResponse| { &m.keyNames },
                    |m: &mut KeystoreResponse| { &mut m.keyNames },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has",
                    |m: &KeystoreResponse| { &m.has },
                    |m: &mut KeystoreResponse| { &mut m.has },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeystoreResponse>(
                    "KeystoreResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeystoreResponse {
        static mut instance: ::protobuf::lazy::Lazy<KeystoreResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeystoreResponse::new)
        }
    }
}

impl ::protobuf::Clear for KeystoreResponse {
    fn clear(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
        self.privateKey.clear();
        self.keyNames.clear();
        self.has = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeystoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeystoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistRequest {
    // message fields
    pub cids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistRequest {
    fn default() -> &'a PersistRequest {
        <PersistRequest as ::protobuf::Message>::default_instance()
    }
}

impl PersistRequest {
    pub fn new() -> PersistRequest {
        ::std::default::Default::default()
    }

    // repeated string cids = 1;


    pub fn get_cids(&self) -> &[::std::string::String] {
        &self.cids
    }
    pub fn clear_cids(&mut self) {
        self.cids.clear();
    }

    // Param is passed by value, moved
    pub fn set_cids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cids
    }

    // Take field
    pub fn take_cids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PersistRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistRequest {
        PersistRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cids",
                    |m: &PersistRequest| { &m.cids },
                    |m: &mut PersistRequest| { &mut m.cids },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistRequest>(
                    "PersistRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PersistRequest {
        static mut instance: ::protobuf::lazy::Lazy<PersistRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PersistRequest::new)
        }
    }
}

impl ::protobuf::Clear for PersistRequest {
    fn clear(&mut self) {
        self.cids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistResponse {
    // message fields
    pub status: ::std::collections::HashMap<::std::string::String, bool>,
    pub errors: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistResponse {
    fn default() -> &'a PersistResponse {
        <PersistResponse as ::protobuf::Message>::default_instance()
    }
}

impl PersistResponse {
    pub fn new() -> PersistResponse {
        ::std::default::Default::default()
    }

    // repeated .pb.PersistResponse.StatusEntry status = 1;


    pub fn get_status(&self) -> &::std::collections::HashMap<::std::string::String, bool> {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::collections::HashMap<::std::string::String, bool>) {
        self.status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, bool> {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::collections::HashMap<::std::string::String, bool> {
        ::std::mem::replace(&mut self.status, ::std::collections::HashMap::new())
    }

    // repeated .pb.PersistResponse.ErrorsEntry errors = 2;


    pub fn get_errors(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.errors
    }
    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_errors(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.errors
    }

    // Take field
    pub fn take_errors(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.errors, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PersistResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.errors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(1, &self.status);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.errors);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(1, &self.status, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.errors, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistResponse {
        PersistResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(
                    "status",
                    |m: &PersistResponse| { &m.status },
                    |m: &mut PersistResponse| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "errors",
                    |m: &PersistResponse| { &m.errors },
                    |m: &mut PersistResponse| { &mut m.errors },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistResponse>(
                    "PersistResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PersistResponse {
        static mut instance: ::protobuf::lazy::Lazy<PersistResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PersistResponse::new)
        }
    }
}

impl ::protobuf::Clear for PersistResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.errors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum P2PREQTYPE {
    CLOSE = 0,
    FORWARD = 1,
    LISTEN = 2,
    LS = 3,
}

impl ::protobuf::ProtobufEnum for P2PREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<P2PREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(P2PREQTYPE::CLOSE),
            1 => ::std::option::Option::Some(P2PREQTYPE::FORWARD),
            2 => ::std::option::Option::Some(P2PREQTYPE::LISTEN),
            3 => ::std::option::Option::Some(P2PREQTYPE::LS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [P2PREQTYPE] = &[
            P2PREQTYPE::CLOSE,
            P2PREQTYPE::FORWARD,
            P2PREQTYPE::LISTEN,
            P2PREQTYPE::LS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<P2PREQTYPE>("P2PREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for P2PREQTYPE {
}

impl ::std::default::Default for P2PREQTYPE {
    fn default() -> Self {
        P2PREQTYPE::CLOSE
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CONNMGMTREQTYPE {
    CM_CONNECT = 0,
    CM_DISCONNECT = 1,
    CM_STATUS = 2,
    CM_GET_PEERS = 3,
}

impl ::protobuf::ProtobufEnum for CONNMGMTREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CONNMGMTREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_CONNECT),
            1 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_DISCONNECT),
            2 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_STATUS),
            3 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_GET_PEERS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CONNMGMTREQTYPE] = &[
            CONNMGMTREQTYPE::CM_CONNECT,
            CONNMGMTREQTYPE::CM_DISCONNECT,
            CONNMGMTREQTYPE::CM_STATUS,
            CONNMGMTREQTYPE::CM_GET_PEERS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<CONNMGMTREQTYPE>("CONNMGMTREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CONNMGMTREQTYPE {
}

impl ::std::default::Default for CONNMGMTREQTYPE {
    fn default() -> Self {
        CONNMGMTREQTYPE::CM_CONNECT
    }
}

impl ::protobuf::reflect::ProtobufValue for CONNMGMTREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EXTRASREQTYPE {
    EX_ENABLE = 0,
    EX_DISABLE = 1,
}

impl ::protobuf::ProtobufEnum for EXTRASREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EXTRASREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(EXTRASREQTYPE::EX_ENABLE),
            1 => ::std::option::Option::Some(EXTRASREQTYPE::EX_DISABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EXTRASREQTYPE] = &[
            EXTRASREQTYPE::EX_ENABLE,
            EXTRASREQTYPE::EX_DISABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<EXTRASREQTYPE>("EXTRASREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EXTRASREQTYPE {
}

impl ::std::default::Default for EXTRASREQTYPE {
    fn default() -> Self {
        EXTRASREQTYPE::EX_ENABLE
    }
}

impl ::protobuf::reflect::ProtobufValue for EXTRASREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EXTRASTYPE {
    IDENTIFY = 0,
    PUBSUB = 1,
    DISCOVERY = 2,
    MDNS = 3,
}

impl ::protobuf::ProtobufEnum for EXTRASTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EXTRASTYPE> {
        match value {
            0 => ::std::option::Option::Some(EXTRASTYPE::IDENTIFY),
            1 => ::std::option::Option::Some(EXTRASTYPE::PUBSUB),
            2 => ::std::option::Option::Some(EXTRASTYPE::DISCOVERY),
            3 => ::std::option::Option::Some(EXTRASTYPE::MDNS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EXTRASTYPE] = &[
            EXTRASTYPE::IDENTIFY,
            EXTRASTYPE::PUBSUB,
            EXTRASTYPE::DISCOVERY,
            EXTRASTYPE::MDNS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<EXTRASTYPE>("EXTRASTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EXTRASTYPE {
}

impl ::std::default::Default for EXTRASTYPE {
    fn default() -> Self {
        EXTRASTYPE::IDENTIFY
    }
}

impl ::protobuf::reflect::ProtobufValue for EXTRASTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BSREQTYPE {
    BS_DELETE = 0,
    BS_PUT = 1,
    BS_PUT_MANY = 2,
    BS_GET = 3,
    BS_GET_MANY = 4,
    BS_GET_ALL = 5,
    BS_GET_STATS = 6,
    BS_HAS = 7,
    BS_HASH_ON_READ_ENABLE = 8,
    BS_HASH_ON_READ_DISABLE = 9,
}

impl ::protobuf::ProtobufEnum for BSREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BSREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(BSREQTYPE::BS_DELETE),
            1 => ::std::option::Option::Some(BSREQTYPE::BS_PUT),
            2 => ::std::option::Option::Some(BSREQTYPE::BS_PUT_MANY),
            3 => ::std::option::Option::Some(BSREQTYPE::BS_GET),
            4 => ::std::option::Option::Some(BSREQTYPE::BS_GET_MANY),
            5 => ::std::option::Option::Some(BSREQTYPE::BS_GET_ALL),
            6 => ::std::option::Option::Some(BSREQTYPE::BS_GET_STATS),
            7 => ::std::option::Option::Some(BSREQTYPE::BS_HAS),
            8 => ::std::option::Option::Some(BSREQTYPE::BS_HASH_ON_READ_ENABLE),
            9 => ::std::option::Option::Some(BSREQTYPE::BS_HASH_ON_READ_DISABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BSREQTYPE] = &[
            BSREQTYPE::BS_DELETE,
            BSREQTYPE::BS_PUT,
            BSREQTYPE::BS_PUT_MANY,
            BSREQTYPE::BS_GET,
            BSREQTYPE::BS_GET_MANY,
            BSREQTYPE::BS_GET_ALL,
            BSREQTYPE::BS_GET_STATS,
            BSREQTYPE::BS_HAS,
            BSREQTYPE::BS_HASH_ON_READ_ENABLE,
            BSREQTYPE::BS_HASH_ON_READ_DISABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<BSREQTYPE>("BSREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BSREQTYPE {
}

impl ::std::default::Default for BSREQTYPE {
    fn default() -> Self {
        BSREQTYPE::BS_DELETE
    }
}

impl ::protobuf::reflect::ProtobufValue for BSREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BSREQOPTS {
    DEFAULT = 0,
    BS_FORCE = 1,
}

impl ::protobuf::ProtobufEnum for BSREQOPTS {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BSREQOPTS> {
        match value {
            0 => ::std::option::Option::Some(BSREQOPTS::DEFAULT),
            1 => ::std::option::Option::Some(BSREQOPTS::BS_FORCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BSREQOPTS] = &[
            BSREQOPTS::DEFAULT,
            BSREQOPTS::BS_FORCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<BSREQOPTS>("BSREQOPTS", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BSREQOPTS {
}

impl ::std::default::Default for BSREQOPTS {
    fn default() -> Self {
        BSREQOPTS::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for BSREQOPTS {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DAGREQTYPE {
    DAG_PUT = 0,
    DAG_GET = 1,
    DAG_NEW_NODE = 2,
    DAG_ADD_LINKS = 3,
    DAG_GET_LINKS = 4,
    DAG_STAT = 5,
}

impl ::protobuf::ProtobufEnum for DAGREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DAGREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(DAGREQTYPE::DAG_PUT),
            1 => ::std::option::Option::Some(DAGREQTYPE::DAG_GET),
            2 => ::std::option::Option::Some(DAGREQTYPE::DAG_NEW_NODE),
            3 => ::std::option::Option::Some(DAGREQTYPE::DAG_ADD_LINKS),
            4 => ::std::option::Option::Some(DAGREQTYPE::DAG_GET_LINKS),
            5 => ::std::option::Option::Some(DAGREQTYPE::DAG_STAT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DAGREQTYPE] = &[
            DAGREQTYPE::DAG_PUT,
            DAGREQTYPE::DAG_GET,
            DAGREQTYPE::DAG_NEW_NODE,
            DAGREQTYPE::DAG_ADD_LINKS,
            DAGREQTYPE::DAG_GET_LINKS,
            DAGREQTYPE::DAG_STAT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<DAGREQTYPE>("DAGREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DAGREQTYPE {
}

impl ::std::default::Default for DAGREQTYPE {
    fn default() -> Self {
        DAGREQTYPE::DAG_PUT
    }
}

impl ::protobuf::reflect::ProtobufValue for DAGREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum KSREQTYPE {
    KS_HAS = 0,
    KS_GET = 1,
    KS_PUT = 2,
    KS_DELETE = 3,
    KS_LIST = 4,
}

impl ::protobuf::ProtobufEnum for KSREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KSREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(KSREQTYPE::KS_HAS),
            1 => ::std::option::Option::Some(KSREQTYPE::KS_GET),
            2 => ::std::option::Option::Some(KSREQTYPE::KS_PUT),
            3 => ::std::option::Option::Some(KSREQTYPE::KS_DELETE),
            4 => ::std::option::Option::Some(KSREQTYPE::KS_LIST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [KSREQTYPE] = &[
            KSREQTYPE::KS_HAS,
            KSREQTYPE::KS_GET,
            KSREQTYPE::KS_PUT,
            KSREQTYPE::KS_DELETE,
            KSREQTYPE::KS_LIST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<KSREQTYPE>("KSREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for KSREQTYPE {
}

impl ::std::default::Default for KSREQTYPE {
    fn default() -> Self {
        KSREQTYPE::KS_HAS
    }
}

impl ::protobuf::reflect::ProtobufValue for KSREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nnode.proto\x12\x02pb\x1a\nutil.proto\"\xd8\x02\n\nP2PRequest\x120\n\
    \x0brequestType\x18\x01\x20\x01(\x0e2\x0e.pb.P2PREQTYPER\x0brequestType\
    \x12\x10\n\x03all\x18\x02\x20\x01(\x08R\x03all\x12\x18\n\x07verbose\x18\
    \x03\x20\x01(\x08R\x07verbose\x12\"\n\x0cprotocolName\x18\x04\x20\x01(\t\
    R\x0cprotocolName\x12$\n\rlistenAddress\x18\x05\x20\x01(\tR\rlistenAddre\
    ss\x12$\n\rtargetAddress\x18\x06\x20\x01(\tR\rtargetAddress\x12$\n\rremo\
    teAddress\x18\x07\x20\x01(\tR\rremoteAddress\x122\n\x14allowCustomProtoc\
    ols\x18\x08\x20\x01(\x08R\x14allowCustomProtocols\x12\"\n\x0creportPeerI\
    D\x18\t\x20\x01(\x08R\x0creportPeerID\"\xa8\x01\n\x0bP2PResponse\x120\n\
    \x0brequestType\x18\x01\x20\x01(\x0e2\x0e.pb.P2PREQTYPER\x0brequestType\
    \x12\x14\n\x05names\x18\x02\x20\x03(\tR\x05names\x12\x20\n\x0bconnsClose\
    d\x18\x03\x20\x01(\x05R\x0bconnsClosed\x12/\n\x0bstreamInfos\x18\x04\x20\
    \x03(\x0b2\r.pb.P2PLsInfoR\x0bstreamInfos\"\x91\x01\n\tP2PLsInfo\x12\"\n\
    \x0cprotocolName\x18\x01\x20\x01(\tR\x0cprotocolName\x12$\n\rlistenAddre\
    ss\x18\x02\x20\x01(\tR\rlistenAddress\x12$\n\rtargetAddress\x18\x03\x20\
    \x01(\tR\rtargetAddress\x12\x14\n\x05local\x18\x04\x20\x01(\x08R\x05loca\
    l\",\n\x10GetPeersResponse\x12\x18\n\x07peerIDs\x18\x01\x20\x03(\tR\x07p\
    eerIDs\"\x82\x01\n\x0fConnMgmtRequest\x125\n\x0brequestType\x18\x01\x20\
    \x01(\x0e2\x13.pb.CONNMGMTREQTYPER\x0brequestType\x12\x1e\n\nmultiAddrs\
    \x18\x02\x20\x03(\tR\nmultiAddrs\x12\x18\n\x07peerIDs\x18\x03\x20\x03(\t\
    R\x07peerIDs\"\xed\x02\n\x10ConnMgmtResponse\x125\n\x0brequestType\x18\
    \x01\x20\x01(\x0e2\x13.pb.CONNMGMTREQTYPER\x0brequestType\x12A\n\tconnec\
    ted\x18\x02\x20\x03(\x0b2#.pb.ConnMgmtResponse.ConnectedEntryR\tconnecte\
    d\x128\n\x06status\x18\x03\x20\x03(\x0b2\x20.pb.ConnMgmtResponse.StatusE\
    ntryR\x06status\x12\x18\n\x07peerIDs\x18\x04\x20\x03(\tR\x07peerIDs\x1a<\
    \n\x0eConnectedEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\
    \n\x05value\x18\x02\x20\x01(\x08R\x05value:\x028\x01\x1aM\n\x0bStatusEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12(\n\x05value\x18\x02\
    \x20\x01(\x0b2\x12.pb.ConnMgmtStatusR\x05value:\x028\x01\"L\n\x0eConnMgm\
    tStatus\x12\"\n\x0cdisconnected\x18\x01\x20\x01(\x08R\x0cdisconnected\
    \x12\x16\n\x06reason\x18\x02\x20\x01(\tR\x06reason\"z\n\rExtrasRequest\
    \x123\n\x0brequestType\x18\x01\x20\x01(\x0e2\x11.pb.EXTRASREQTYPER\x0bre\
    questType\x124\n\rextrasFeature\x18\x02\x20\x01(\x0e2\x0e.pb.EXTRASTYPER\
    \rextrasFeature\"\xd1\x01\n\x11BlockstoreRequest\x12/\n\x0brequestType\
    \x18\x01\x20\x01(\x0e2\r.pb.BSREQTYPER\x0brequestType\x12'\n\x07reqOpts\
    \x18\x02\x20\x03(\x0e2\r.pb.BSREQOPTSR\x07reqOpts\x12\x12\n\x04cids\x18\
    \x03\x20\x03(\tR\x04cids\x12\x12\n\x04data\x18\x04\x20\x03(\x0cR\x04data\
    \x12\x1e\n\ncidVersion\x18\x05\x20\x01(\tR\ncidVersion\x12\x1a\n\x08hash\
    Func\x18\x07\x20\x01(\tR\x08hashFunc\"h\n\x12BlockstoreResponse\x12/\n\
    \x0brequestType\x18\x01\x20\x01(\x0e2\r.pb.BSREQTYPER\x0brequestType\x12\
    !\n\x06blocks\x18\x02\x20\x03(\x0b2\t.pb.BlockR\x06blocks\"A\n\x05Block\
    \x12\x10\n\x03cid\x18\x01\x20\x01(\tR\x03cid\x12\x12\n\x04data\x18\x02\
    \x20\x01(\x0cR\x04data\x12\x12\n\x04size\x18\x03\x20\x01(\x03R\x04size\"\
    \xe7\x02\n\nDagRequest\x120\n\x0brequestType\x18\x01\x20\x01(\x0e2\x0e.p\
    b.DAGREQTYPER\x0brequestType\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04\
    data\x12&\n\x0eobjectEncoding\x18\x03\x20\x01(\tR\x0eobjectEncoding\x120\
    \n\x13serializationFormat\x18\x04\x20\x01(\tR\x13serializationFormat\x12\
    \x1a\n\x08hashFunc\x18\x05\x20\x01(\tR\x08hashFunc\x12\x1e\n\ncidVersion\
    \x18\x06\x20\x01(\x03R\ncidVersion\x12\x12\n\x04hash\x18\x07\x20\x01(\tR\
    \x04hash\x12/\n\x05links\x18\x08\x20\x03(\x0b2\x19.pb.DagRequest.LinksEn\
    tryR\x05links\x1a8\n\nLinksEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x9f\
    \x02\n\x0bDagResponse\x120\n\x0brequestType\x18\x01\x20\x01(\x0e2\x0e.pb\
    .DAGREQTYPER\x0brequestType\x12\x16\n\x06hashes\x18\x02\x20\x03(\tR\x06h\
    ashes\x12\x18\n\x07rawData\x18\x03\x20\x01(\x0cR\x07rawData\x12\"\n\x05l\
    inks\x18\x04\x20\x03(\x0b2\x0c.pb.IPLDLinkR\x05links\x12<\n\tnodeStats\
    \x18\x05\x20\x03(\x0b2\x1e.pb.DagResponse.NodeStatsEntryR\tnodeStats\x1a\
    J\n\x0eNodeStatsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\"\
    \n\x05value\x18\x02\x20\x01(\x0b2\x0c.pb.IPLDStatR\x05value:\x028\x01\"\
    \xa4\x01\n\x08IPLDStat\x12\x1a\n\x08numLinks\x18\x01\x20\x01(\x03R\x08nu\
    mLinks\x12\x1c\n\tblockSize\x18\x02\x20\x01(\x03R\tblockSize\x12\x1a\n\
    \x08linkSize\x18\x03\x20\x01(\x03R\x08linkSize\x12&\n\x0ecumulativeSize\
    \x18\x04\x20\x01(\x03R\x0ecumulativeSize\x12\x1a\n\x08dataSize\x18\x05\
    \x20\x01(\x03R\x08dataSize\"F\n\x08IPLDLink\x12\x12\n\x04hash\x18\x01\
    \x20\x01(\x0cR\x04hash\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x12\n\x04size\x18\x03\x20\x01(\x04R\x04size\"B\n\x08IPLDNode\x12\"\n\
    \x05links\x18\x02\x20\x03(\x0b2\x0c.pb.IPLDLinkR\x05links\x12\x12\n\x04d\
    ata\x18\x01\x20\x01(\x0cR\x04data\"v\n\x0fKeystoreRequest\x12/\n\x0brequ\
    estType\x18\x01\x20\x01(\x0e2\r.pb.KSREQTYPER\x0brequestType\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x12\x1e\n\nprivateKey\x18\x03\x20\
    \x01(\x0cR\nprivateKey\"\x91\x01\n\x10KeystoreResponse\x12/\n\x0brequest\
    Type\x18\x01\x20\x01(\x0e2\r.pb.KSREQTYPER\x0brequestType\x12\x1e\n\npri\
    vateKey\x18\x02\x20\x01(\x0cR\nprivateKey\x12\x1a\n\x08keyNames\x18\x03\
    \x20\x03(\tR\x08keyNames\x12\x10\n\x03has\x18\x04\x20\x01(\x08R\x03has\"\
    $\n\x0ePersistRequest\x12\x12\n\x04cids\x18\x01\x20\x03(\tR\x04cids\"\
    \xf9\x01\n\x0fPersistResponse\x127\n\x06status\x18\x01\x20\x03(\x0b2\x1f\
    .pb.PersistResponse.StatusEntryR\x06status\x127\n\x06errors\x18\x02\x20\
    \x03(\x0b2\x1f.pb.PersistResponse.ErrorsEntryR\x06errors\x1a9\n\x0bStatu\
    sEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x08R\x05value:\x028\x01\x1a9\n\x0bErrorsEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01*8\n\nP2PREQTYPE\x12\t\n\x05CLOSE\x10\0\x12\x0b\n\
    \x07FORWARD\x10\x01\x12\n\n\x06LISTEN\x10\x02\x12\x06\n\x02LS\x10\x03*U\
    \n\x0fCONNMGMTREQTYPE\x12\x0e\n\nCM_CONNECT\x10\0\x12\x11\n\rCM_DISCONNE\
    CT\x10\x01\x12\r\n\tCM_STATUS\x10\x02\x12\x10\n\x0cCM_GET_PEERS\x10\x03*\
    .\n\rEXTRASREQTYPE\x12\r\n\tEX_ENABLE\x10\0\x12\x0e\n\nEX_DISABLE\x10\
    \x01*?\n\nEXTRASTYPE\x12\x0c\n\x08IDENTIFY\x10\0\x12\n\n\x06PUBSUB\x10\
    \x01\x12\r\n\tDISCOVERY\x10\x02\x12\x08\n\x04MDNS\x10\x03*\xbb\x01\n\tBS\
    REQTYPE\x12\r\n\tBS_DELETE\x10\0\x12\n\n\x06BS_PUT\x10\x01\x12\x0f\n\x0b\
    BS_PUT_MANY\x10\x02\x12\n\n\x06BS_GET\x10\x03\x12\x0f\n\x0bBS_GET_MANY\
    \x10\x04\x12\x0e\n\nBS_GET_ALL\x10\x05\x12\x10\n\x0cBS_GET_STATS\x10\x06\
    \x12\n\n\x06BS_HAS\x10\x07\x12\x1a\n\x16BS_HASH_ON_READ_ENABLE\x10\x08\
    \x12\x1b\n\x17BS_HASH_ON_READ_DISABLE\x10\t*&\n\tBSREQOPTS\x12\x0b\n\x07\
    DEFAULT\x10\0\x12\x0c\n\x08BS_FORCE\x10\x01*l\n\nDAGREQTYPE\x12\x0b\n\
    \x07DAG_PUT\x10\0\x12\x0b\n\x07DAG_GET\x10\x01\x12\x10\n\x0cDAG_NEW_NODE\
    \x10\x02\x12\x11\n\rDAG_ADD_LINKS\x10\x03\x12\x11\n\rDAG_GET_LINKS\x10\
    \x04\x12\x0c\n\x08DAG_STAT\x10\x05*K\n\tKSREQTYPE\x12\n\n\x06KS_HAS\x10\
    \0\x12\n\n\x06KS_GET\x10\x01\x12\n\n\x06KS_PUT\x10\x02\x12\r\n\tKS_DELET\
    E\x10\x03\x12\x0b\n\x07KS_LIST\x10\x042\xb7\x03\n\x07NodeAPI\x127\n\x08C\
    onnMgmt\x12\x13.pb.ConnMgmtRequest\x1a\x14.pb.ConnMgmtResponse\"\0\x12(\
    \n\x06Extras\x12\x11.pb.ExtrasRequest\x1a\t.pb.Empty\"\0\x12(\n\x03P2P\
    \x12\x0e.pb.P2PRequest\x1a\x0f.pb.P2PResponse\"\0\x12=\n\nBlockstore\x12\
    \x15.pb.BlockstoreRequest\x1a\x16.pb.BlockstoreResponse\"\0\x12G\n\x10Bl\
    ockstoreStream\x12\x15.pb.BlockstoreRequest\x1a\x16.pb.BlockstoreRespons\
    e\"\0(\x010\x01\x12(\n\x03Dag\x12\x0e.pb.DagRequest\x1a\x0f.pb.DagRespon\
    se\"\0\x127\n\x08Keystore\x12\x13.pb.KeystoreRequest\x1a\x14.pb.Keystore\
    Response\"\0\x124\n\x07Persist\x12\x12.pb.PersistRequest\x1a\x13.pb.Pers\
    istResponse\"\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
